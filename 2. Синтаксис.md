Перед тем, как прямиком перейти к основной теме этого раздела, я бы хотел повторить: несмотря на то, что синтаксис CoffeeScript похож на синтаксис JavaScript, CoffeeScript не является подмножеством JavaScript. Поэтому нельзя писать JS-конструкции в CoffeeScript-файле, так как при компиляции компилятор выдас ошибку. Если вы пишете код на CoffeeScript — то он должен быть написан на чистом CoffeeScript. Не надо смешивать два разных языка.

Почему CoffeeScript не является подмножеством? Потому что CoffeeScript уделяет весьма значительное внимание чистоте и лаконичности кода. В CoffeeScript многие ключевые слова из JavaScript были убраны, благодаря чему сократилось количество ошибок и кода.

Кстати, я нахожу весьма странным то, что компилятор CoffeeScript написан на CoffeeScript! Похоже, что на вопрос «что было раньше — курица или яйцо»  наконец-то найден ответ!

Итак, давайте рассмотрим основы. В CoffeeScript нет нужды добавлять точку с запятой в конце строки — компилятор автоматически её добавит при компиляции. Точки с запятой являются причиной многочисленных дискуссий в JavaScript сообществе, в частности, из-за странного поведения интерпретатора при их обработке. Слава богу, CoffeeScript решает эту проблему просто убрав точки с запятой из своего синтаксиса.

Комментарии форматируются так же, как и в языке Ruby, начинаясь со знака `#`.

```coffeescript
# A comment
```

Мультистрочные комментарии также поддерживаются. Они начинаются и заканчиваются тремя символами `#`.

```coffeescript
###
   Комментарий, который занимает
   несколько строк.
###
```

Как я уже упомянул ранее, CoffeeScript весьма лаконичен. На практике это означает к примеру то, что вы можете заменить фигурные скобки ({}) tab'ом. Эта фича вдохновлена языком Python. Есть и недостатки — придётся внимательно следить за форматированием кода.

## Переменные и область видимости
CoffeeScript устраняет одну из основных проблем JavaScript — глобальные переменные. В JavaScript весьма легко объявить глобальную переменную, забыв добавить ключевое слово `var` перед её именем. CoffeeScript решает эту проблему убирая глобальные переменные. После компиляции CoffeeScript оборачивает весь наш код в анонимную функцию, тем самым разделяя глобальную и локальную области видимости. Рассмотрим в качестве примера простое объявление переменной и присваивание ей значения:

```coffeescript
myVariable = "test"
```

Скомпилированный JS-код:

```javascript
var myVariable;
myVariable = "test";
```

Как вы можете видеть, в этом коде совершается присвоение локальной переменной. CoffeeScript делает шаг вперёд и предотвращает довольно распространённую ошибку JavaScript-разработчиков.

Однако иногда бывает полезно создать глобальную переменную. Вы можете сделать переменную свойством глобального объекта (в браузерах — window), либо с помощью следующего способа:

```coffeescript
exports = this
exports.MyVariable = "foo-bar"
```

В корневом контексте this является глобальным объектом,и путём создания переменной exports вы делаете более понятным то, какие глобальные переменные задаются в вашем скрипте. Кроме того, такой способ позволяет использовать модули CommonJS, которые мы рассмотрим несколько позже.

## Функции
CoffeeScript сокращает довольно крупное объявление функции небольшой стрелкой: ->. Функции могут помещаться в одну строку или быть мультистрочными. Последнее выражение в функции неявно возвращается. Иначе говоря, вам не нужно использовать ключевое слово return, если вы захотите, чтобы функция возвращала что-либо — просто поместите это что-либо в конце.

Давайте рассмотрим такой пример:

```coffeescript
func = -> "bar"
```

Скомпилированный вариант:

```javascript
var func;
func = function() {
  return "bar";
};
```

Как вы можете видеть, стрелка (->) скомпилировалось в выражение function, а перед строкой "bar" автоматически добавилось ключевое слово return.

Я уже говорил ранее, что нет причин не использовать мультистрочные функции — главное, чтобы отступы были корректны.

```coffeescript
func = ->
  # An extra line
  "bar"
```

### Аргументы функций
Как быть с аргументами функций? Что же, CoffeeScript предоставляет возможность объявить аргументы в скобках перед стрелокй.

```coffeescript
times = (a, b) -> a * b
```

CoffeeScript также поддерживает задание значений аргументов по умолчанию, например:

```coffeescript
times = (a = 1, b = 2) -> a * b
```

Также вы можете использовать три точки (...), чтобы указать на то, что в функцию может быть передано несколько аргументов:

```coffeescript
sum = (nums...) -> 
  result = 0
  nums.forEach (n) -> result += n
  result
```

В примере выше перменная nums является массивом со всеми переданными аргументами. Это не объект, а именно массив, так что вам не придётся беспокоиться об использовании `Array.prototype.splice` или `jQuery.makeArray()`.

```coffeescript
trigger = (events...) ->
  events.splice(1, 0, this)
  this.constructor.trigger.apply(events)
```

### Вызов функций
В CoffeeScript функции могут быть вызваны так же, как и в JavaScript: со скобками () или с помощью apply() / call(). Также функции могут быть вызваны без скобок, как в Ruby или Python:

```coffeescript
a = "Howdy!"

alert a
# Аналог:
alert(a)

alert inspect a
# Аналог:
alert(inspect(a))
```

Я рекомендую использовать скобки в тех случаях, когда не совсем очевидно, что вызывается и с какими аргументами. Например, в последней строчке примера я бы определенно поставил скобки.

```coffeescript
alert inspect(a)
```

Отмечу, что если вы хотите вызвать функцию без аргументов, то CoffeeScript не сможет определить, намерены вы вызвать функцию или присвоить значение переменной. В этом плане поведение CoffeeScript несколько отличается от Ruby, в котором в таких случаях будет вызвана функция. Такое поведение также несколько схоже с поведением в Python. Эта тонкость была причиной нескольких ошибок в моих CoffeeScript-программах, поэтому внимательно отслеживайте случаи вызова функций без аргументов и добавляйте к ним круглые скобки.

### Контекст функции
В JavaScript часто изменяется контекст выполнения функции, особенно при работе с коллбэками событий. Поэтому CoffeeScript предоставляет инструменты для предотвращения ошибок при работе с контекстом. Одним из таких инструментов является «жирная» стрелка: `=>`.

Использование «жирной» стрелки гарантирует, что контекст исполнения функции будет привязан к локальному. Например:

```coffeescript
this.clickHandler = -> alert "clicked"
element.addEventListener "click", (e) => this.clickHandler(e)
```

Причина по которой вы можете воспользоваться таким способом — то, что коллбэк из `addEventListener` будет выполнен в контексте элемента, то есть `this` будет являться элементом. Если вы хотите использовать локальный контекст без костылей вида `self = this`, «жирная» стрелка — это то, что вам нужно.

Эта идея привязки аналогична методу `proxy()` из jQuery или методу `bind()` из ES5.

## Литеральная нотация объектов и определение массивов
Объекты могут быть определены так же, как и в JavaScript — с помощью пары фигурных скобок и конструкции вида свойство/значение внутри. Однако CoffeeScript не требует обязательного использования фигурных скобок. А ещё вы можете использовать отступы и переносы строк вместо постановки запятых после определения свойства.

```coffeescript
object1 = {one: 1, two: 2}

# Без фигурных скобок
object2 = one: 1, two: 2

# Использование переноса строки вместо запятой
object3 = 
  one: 1
  two: 2

User.create(name: "John Smith")
```

Массивы также могут использовать пробел вместо запятой в качестве разделителя. Однако, для массивов квадратные скобки ([]) требуются обязательно.

```coffeescript
array1 = [1, 2, 3]

array2 = [
  1
  2
  3
]

array3 = [1,2,3,]
```

В примере выше CoffeeScript при компиляции удалит запятую после последнего элемента массива `array3`. Зачастую эта запятая является источником ошибок, но с CoffeeScript вам не придётся об этом беспокоиться.

## Условия
Соглашение о необязательных круглых скобках действует и в отношении ключевых слов if/else.

```coffeescript
if true == true
  "We're ok"

if true != true then "Panic"

# Аналогично следующему:
#  (1 > 0) ? "Ok" : "Y2K!"
if 1 > 0 then "Ok" else "Y2K!"
```

Как вы можете видеть выше, если всё условное выражение располагается на одной строке, вам придётся использовать ключевое слово `then`, чтобы компилятор знал, где начинается следующий блок кода. Условные операторы (?:) не поддерживаются, вместо них следует использовать однострочное выражение if/else.

CoffeeScript также поддерживает условные выражения в стиле языка Ruby.

```coffeescript
alert "It's cold!" if heat < 5
```

Вместо использования восклицательного знака (!) для отрицания вы можете использовать ключевое слово `not`. Оно позволяет сделать код более читаемым во многих случаях.

```coffeescript
if not true then "Panic"
```